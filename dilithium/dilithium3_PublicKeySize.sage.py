

# This file was *autogenerated* from the file dilithium3_PublicKeySize.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_23 = Integer(23); _sage_const_13 = Integer(13); _sage_const_1 = Integer(1); _sage_const_4 = Integer(4); _sage_const_256 = Integer(256); _sage_const_6 = Integer(6); _sage_const_5 = Integer(5); _sage_const_49 = Integer(49); _sage_const_19 = Integer(19); _sage_const_32 = Integer(32); _sage_const_16 = Integer(16); _sage_const_0 = Integer(0); _sage_const_255 = Integer(255)#DILITHIUM
import random
from random import choice, shuffle
import numpy as np

#Official Parameters Security Level 3
q =  _sage_const_2 **_sage_const_23  - _sage_const_2 **_sage_const_13  + _sage_const_1      
k = _sage_const_4 
d = _sage_const_256        
n, m = _sage_const_6 , _sage_const_5 
beta = _sage_const_4        
gamma = _sage_const_49 *_sage_const_4      
beta_prima = _sage_const_2 **_sage_const_19  - gamma - _sage_const_1 
R = IntegerModRing(q)  
PR = PolynomialRing(R, names=('X',)); (X,) = PR._first_ngens(1)
Rk = PR.quotient(X**d + _sage_const_1 )  
delta_s = (q - _sage_const_1 )/_sage_const_32  - _sage_const_1 
T = _sage_const_2 **_sage_const_13 
s = _sage_const_2 **_sage_const_16 

load("tree.sage")
load("NTT.sage")
load("auxiliar_functions.sage")
tree, r_list = build_tree(_sage_const_1 , d)
tree_inv = build_inverse_tree_from(tree, q, _sage_const_1 )

#Simulate the Prover role
class Prover:
    def __init__(self):
        self.y_1 = None
        self.y_2 = None
        self.s1 = None
        self.s2 = None
        self.z1 = None
        self.z2 = None
        self.A = None
        self.t = None
        
    def keygen(self):
        self.s1 = create_vector(beta, m)
        self.s2 = create_vector(beta, n)
        self.A = create_matrix(n, m)
        A_ntt = [NTT_vector(self.A[i]) for i in range(n)]
        s1_ntt = NTT_vector(self.s1)
        t_ = multiply_vector_matrix(s1_ntt, A_ntt, n, m)
        self.t = sum_vectors(INTT_vector(t_), self.s2, n)
        self.y_A = None
        self.t_1 = HIGH_s(self.t, T)

        return self.A, self.t
        
    #Commitment
    def step1(self):
        self.y = create_vector(gamma + beta_prima, m)

        y_ntt = NTT_vector(self.y)
        A_ntt = [NTT_vector(self.A[i]) for i in range(n)]
        y_A_ntt = multiply_vector_matrix(y_ntt, A_ntt, n, m)
        y_A_intt = INTT_vector(y_A_ntt)

        self.y_A = y_A_intt

        self.w = HIGH_s(self.y_A, s)
        
        return self.w
    
    def step2(self, c):
        s1_ = NTT_vector(self.s1)
        s2_ = NTT_vector(self.s2)
        c_ntt = NTT(c)
        z_= multiply_constant_vector(c_ntt, s1_)
        z_1 = INTT_vector(z_)
        
        z = sum_vectors(z_1,  self.y, m)
        c_s2_ntt= multiply_constant_vector(c_ntt, s2_)
        c_s2_intt = INTT_vector(c_s2_ntt)
        low_content = substract_vectors(self.y_A, c_s2_intt, n)
        low_cond = LOW_s(low_content)

        if not is_in_range(z, beta_prima) or not is_in_range(low_cond, delta_s - gamma):
            return None, None
        else:
            t_0 = LOW_s(self.t, T)
            t0_c = multiply_constant_vector(c_ntt, NTT_vector(t_0))
            t0_c_intt = INTT_vector(t0_c)
            if not is_in_range(t0_c_intt, delta_s):
                return None, None
            A_z = multiply_vector_matrix(NTT_vector(z), [NTT_vector(self.A[i]) for i in range(n)], n, m)
            A_z_intt = INTT_vector(A_z)
            c_t_1_ntt = multiply_constant_vector(c_ntt, NTT_vector(self.t_1))
            c_t_1_intt = INTT_vector(c_t_1_ntt)
            AZ_ct = substract_vectors(A_z_intt, c_t_1_intt, n)
            return z, HINT(AZ_ct, t0_c_intt)

#Simulate the Verifier role
class Verifier:
    def __init__(self):
        self.c = None
    
    #Challenge
    def step1(self, A, t):
        self.c = generate_c() 
        shuffle(self.c)
        return Rk(self.c)
    
    def step2(self, z, w_, A, t):
        A_z_ntt = multiply_vector_matrix(NTT_vector(z), [NTT_vector(A[i]) for i in range(n)], n, m)
        A_z_intt = INTT_vector(A_z_ntt)
        c_t_ntt = multiply_constant_vector(NTT(self.c), NTT_vector(t))
        c_t_intt = INTT_vector(c_t_ntt)
        w_result = substract_vectors(A_z_intt, c_t_intt, n)
        w_high = HIGH_s(w_result, s)
        if is_in_range(z, beta_prima) and w_high == w_:
            return True
        else:
            return False

#We simulate the scheme Dilithium
v = Verifier()
p = Prover()

def HINT(f1, f2):
    high_f1 = HIGH_s(f1, s)
    print(high_f1[_sage_const_0 ][_sage_const_255 ])
    high_f2 = HIGH_s(f2, s)
    print(high_f2[_sage_const_0 ][_sage_const_255 ])
    hint = []
    for i in range(n):
        for j in range(d):
            if high_f1[i][j] != high_f2[i][j]:
                hint.append(_sage_const_1 )
            else:
                hint.append(_sage_const_0 )
    return hint
    

def simulate_protocol():
    A, t = p.keygen()
    w = p.step1()
    c = v.step1(A, t)
    z = p.step2(c)
    return  z, w, A, t

while True:
    z, w, A, t = simulate_protocol()
    print("ss")

    if z is None:
            continue
    else:
        boolean = v.step2(z, w, A, t)
        if boolean != False:
            print("Verification:", boolean)
            break

